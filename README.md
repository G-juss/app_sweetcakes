<h1 align="center">Sweetcakes</h1>

###

<div align="center">
  <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/flutter/flutter-original.svg" height="54" alt="flutter logo"  />
  <img width="41" />
  <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/dart/dart-original.svg" height="54" alt="dart logo"  />
  <img width="41" />
  <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/firebase/firebase-plain.svg" height="54" alt="firebase logo"  />
  <img width="41" />
  <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/visualstudio/visualstudio-plain.svg" height="54" alt="visualstudio logo"  />
  <img width="41" />
  <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/github/github-original.svg" height="54" alt="github logo"  />
  <img width="41" />
  <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/chrome/chrome-original.svg" height="54" alt="chrome logo"  />
  <img width="41" />
  <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/figma/figma-original.svg" height="54" alt="figma logo"  />
</div>

###

<p align="center">El Sistema de pedidos para pastelería</p>

###

<p align="left">======================================================================<br> SWEETCAKES — SISTEMA DE PEDIDOS PARA PASTELERÍA<br>======================================================================<br><br>Ingeniería de Software 2 — Sección 233<br>Grupo #3<br><br>Participantes:<br><br>John Fithgerald Ramos Escobar – 62321444<br><br>Miguel Angel Carranza Avilez – 62211533<br><br>Fernanda Nicole Dubón – 62311253<br><br>Génesis Jusselphy Medina Anariba – 62251243<br><br>Liza Valentina Torres Mena – 62311470</p>

###

<div align="center">
  <img height="350" src="https://files.catbox.moe/5urczn.png"  />
</div>

###

<div align="center">
  <img height="350" src="https://files.catbox.moe/axc90n.png"  />
</div>

###

<p align="left">=====================================================================<br>SweetCakes es una aplicación desarrollada en Flutter para digitalizar el proceso de pedidos de una pastelería/repostería. Permite que los clientes:<br>=====================================================================<br><br>•	se registren e inicien sesión,<br>•	naveguen un catálogo de productos,<br>•	agreguen artículos a un carrito,<br>•	confirmen pedidos y consulten su historial.<br>Además, contempla un flujo de administración para gestión de productos e inventario (CRUD), con actualizaciones en tiempo real usando Firebase.<br>Objetivo del sistema:<br>•	Reducir pedidos manuales (WhatsApp/llamadas),<br>•	mejorar la experiencia del cliente,<br>•	permitir control de inventario y pedidos desde un panel interno,<br>•	mantener trazabilidad de datos y consistencia visual (UI/UX).<br><br><br>2.	Alcance y Funcionalidades<br><br><br>2.1 Funcionalidades del Cliente (App)<br>•	Registro e inicio de sesión (Firebase Authentication).<br>•	Visualización de catálogo en cuadrícula (GridView).<br>•	Búsqueda/visualización de productos con imagen, precio y stock.<br>•	Agregar productos al carrito (persistencia por usuario).<br>•	Carrito en tiempo real (actualiza cantidades sin recargar).<br>•	Confirmación de pedido (crea registro de pedido).<br>•	Historial de pedidos (por usuario).<br>2.2 Funcionalidades Administrativas<br>•	Crear producto (nombre, precio, imagen, stock).<br>•	Editar producto (actualizar información y stock).<br>•	Eliminar producto.<br>•	(Opcional) Deshabilitar producto sin borrarlo (campo “activo”).<br>2.3 Entregables de Ingeniería (documentación y diseño)<br>•	Historias de usuario (HU) y trazabilidad.<br>•	Modelo de datos (Firestore).<br>•	Diagramas (Contexto/Contenedores, Clases si aplica).<br>•	Reglas de negocio (stock, validaciones, acceso por rol si aplica).<br>•	Diseño UI/UX (tema pastel, consistencia visual).<br><br><br>3.	Tecnologías y Herramientas<br><br><br>Frontend:<br>•	Flutter (Dart)<br>•	Widgets: MaterialApp, ThemeData, StreamBuilder, GridView, SnackBar<br>Backend (Serverless):<br>•	Firebase Authentication (login/registro)<br>•	Cloud Firestore (productos, carrito, pedidos)<br>Control de versiones:<br>•	Git + GitHub<br>•	Ramas por funcionalidad y Pull Requests<br><br><br>4.	Arquitectura del Proyecto (Análisis Profesional)<br><br><br>4.1 Enfoque: Separación de Responsabilidades (Separation of Concerns)<br>Decisión clave:<br>•	No mezclar lógica de base de datos dentro de Widgets UI.<br>Cómo se implementó:<br>•	Capa de Servicios: FirestoreService (comunicación con Firestore / operaciones CRUD).<br>•	Capa de Modelos: Postre, CarritoItem (tipado fuerte + mapeo).<br>•	Capa UI: pantallas y componentes (Home, Login, etc.) consumen servicios.<br>Beneficios:<br>•	Código desacoplado y mantenible.<br>•	Más fácil de testear (servicios aislables).<br>•	Si el backend cambia (Firebase → API propia), la UI no colapsa: se reemplaza la capa de servicios.<br>4.2 Manejo de datos reactivo (Streams + StreamBuilder)<br>Decisión clave:<br>•	Usar streams para reflejar cambios en tiempo real.<br>Cómo se implementó:<br>•	getProductos() retorna Stream<List<Postre>><br>•	StreamBuilder en Home escucha cambios de Firestore<br>Beneficios:<br>•	Catálogo y/o inventario se actualiza automáticamente.<br>•	UX superior: no se requiere recargar manualmente.<br>4.3 Serialización / Deserialización (Tipado fuerte)<br>Decisión clave:<br>•	Firestore devuelve documentos tipo “Map” (similar a JSON).<br>•	En la app se trabaja con objetos tipados.<br>Cómo se implementó:<br>•	Postre.fromMap(...) y Postre.toMap()<br>•	CarritoItem.fromMap(...) y CarritoItem.toMap()<br>Beneficios:<br>•	Previene errores en tiempo de ejecución por tipos incorrectos.<br>•	Mejor autocompletado, validación y lectura del código.<br>4.4 Theming centralizado (UI/UX consistente)<br>Decisión clave:<br>•	Evitar “valores hardcodeados” (colores, bordes) dispersos.<br>Cómo se implementó:<br>•	ThemeData global en main.dart (ColorScheme, InputDecorationTheme, CardTheme, etc.)<br>Beneficios:<br>•	Consistencia visual de marca “SweetCakes”.<br>•	Mantenimiento eficiente: un cambio impacta toda la app.<br>4.5 Backend serverless (Firebase)<br>Justificación:<br>•	Optimiza tiempo de desarrollo y reduce infraestructura.<br>•	Firestore escala bien para catálogos que pueden variar en atributos.<br>Seguridad:<br>•	Reglas de Firestore para controlar acceso (lectura pública de productos si se define, y carrito/pedidos privados por usuario).<br><br>5.	Estructura del Proyecto (Organización recomendada)<br><br><br>/lib<br>/models<br>- postre.dart<br>- carrito_item.dart<br>/services<br>- firestore_service.dart<br>- auth_service.dart (si aplica)<br>/screens<br>- login_screen.dart<br>- register_screen.dart<br>- home_screen.dart<br>- carrito_screen.dart (si aplica)<br>- admin_screen.dart (si aplica)<br>/widgets<br>- postre_card.dart<br>main.dart<br>Nota:<br>La separación por carpetas permite escalar el proyecto agregando:<br>•	repositorios (repository pattern),<br>•	providers / bloc,<br>•	capa de casos de uso (use cases) si se quisiera mayor robustez.<br><br><br>6.	Modelo de Datos (Firestore)<br><br><br>Colecciones principales:<br>1.	productos (público)<br>•	Documento por producto.<br>•	Campos típicos:<br>o	nombre: string<br>o	precio: number<br>o	imagenUrl: string<br>o	stock: number<br>o	activo: bool (opcional)<br>2.	usuarios/{uid} (privado)<br>•	Documento por usuario (perfil/rol opcional).<br>3.	usuarios/{uid}/carrito (privado por usuario)<br>•	Un documento por producto agregado al carrito.<br>•	Se recomienda usar como ID el id del producto (más fácil para incrementar cantidad).<br>•	Campos:<br>o	id, nombre, precio, imagenUrl, cantidad<br>4.	usuarios/{uid}/pedidos (privado por usuario)<br>•	Documento por pedido.<br>•	Campos sugeridos:<br>o	createdAt: timestamp<br>o	estado: string (Ej: “pendiente”, “confirmado”, “entregado”)<br>o	items: array (detalle del pedido)<br>o	total: number<br><br><br>7.	Lógica del Carrito de Compras (Implementación)<br><br><br>7.1 Modelo CarritoItem (carrito_item.dart)<br>Propósito:<br>•	Representar un ítem del carrito con tipado fuerte.<br>•	Convertir entre “Map” (Firestore) ↔ Objeto (Dart).<br>Campos:<br>•	id, nombre, precio, imagenUrl, cantidad<br>7.2 Servicio FirestoreService (firestore_service.dart)<br>Funciones clave para carrito:<br>•	agregarAlCarrito(postre):<br>o	Si existe el documento del producto en carrito: incrementa cantidad.<br>o	Si no existe: crea documento con cantidad = 1.<br>•	getCarrito():<br>o	Stream<List<CarritoItem>> para ver cambios en tiempo real.<br>7.3 Conexión desde UI (Home / PostreCard)<br>•	Botón “Agregar” llama a agregarAlCarrito()<br>•	Feedback visual con SnackBar (“Agregado al carrito”).<br>Resultado:<br>•	El carrito persiste por usuario.<br>•	Se actualiza solo sin recargar.<br><br><br>8.	Reglas de Negocio (Ejemplos claros)<br><br><br>RB-01: Stock no debe ser negativo.<br>•	Al confirmar pedido, se valida disponibilidad.<br>•	(Opcional) Se descuenta stock con transacción o batch write.<br>RB-02: Carrito es privado por usuario.<br>•	Un usuario no puede leer carrito/pedidos de otros.<br>RB-03: Email único en registro.<br>•	Gestionado por Firebase Authentication.<br>RB-04: Intentos fallidos (si aplica)<br>•	UI bloquea o muestra warning tras varios intentos.<br><br><br>9.	Instalación y Ejecución (Paso a Paso)<br><br><br>Requisitos:<br>•	Flutter SDK instalado<br>•	Dart (incluido con Flutter)<br>•	Git<br>•	Un proyecto en Firebase con:<br>o	Authentication habilitado (Email/Password)<br>o	Cloud Firestore habilitado<br>9.1 Clonar el repositorio<br>•	git clone (URL de tu repositorio)<br>•	cd (carpeta del proyecto)<br>9.2 Instalar dependencias<br>•	flutter pub get<br>9.3 Configurar Firebase<br>Opción A (recomendada):<br>•	Usar FlutterFire CLI para generar firebase_options.dart.<br>Opción B:<br>•	Agregar archivos nativos:<br>o	Android: google-services.json<br>o	iOS: GoogleService-Info.plist<br>9.4 Ejecutar<br>•	Móvil:<br>o	flutter run<br>•	Web:<br>o	flutter run -d chrome<br>Si falla la inicialización:<br>•	revisar configuración Firebase<br>•	revisar que firebase_core esté instalado<br>•	revisar consola/log<br><br><br>10.	Guía de Uso (Cómo probar el sistema)<br><br><br>Flujo Cliente:<br>1.	Abrir app<br>2.	Registrarse (correo/contraseña)<br>3.	Iniciar sesión<br>4.	Ver catálogo (carga automática)<br>5.	Presionar “Agregar” en un producto<br>6.	Abrir Carrito (si existe pantalla)<br>7.	Ver cantidades y total<br>8.	Confirmar pedido<br>9.	Revisar historial de pedidos<br>Flujo Admin:<br>1.	Iniciar sesión con cuenta admin (si hay roles)<br>2.	Ir a panel admin<br>3.	Crear/editar/eliminar productos<br>4.	Ver cambios reflejados instantáneamente en catálogo (streams)<br><br><br>11.	Manejo de Errores y Estados (Buenas prácticas aplicadas)<br><br><br>En StreamBuilder:<br>•	loading: mostrar indicador de carga<br>•	error: snapshot.hasError → mostrar mensaje<br>•	empty: lista vacía → mostrar “No hay productos”<br>En inicialización Firebase:<br>•	envolver en try-catch y registrar errores en consola para diagnóstico.<br><br><br>12.	Trazabilidad (HU → UI → Servicio → Datos)<br><br><br>Se adjunta tabla recomendada para evidenciar trazabilidad del sistema:<br>(Insertar en Word la imagen: “Tabla de trazabilidad HU”.)<br>Ejemplos:<br>•	HU-003 Catálogo → HomeScreen + StreamBuilder → getProductos() → colección productos<br>•	HU-004 Agregar al carrito → PostreCard → agregarAlCarrito() → usuarios/{uid}/carrito<br><br>=====================================================================<br><br>13.	Protocolo de Desarrollo (Qué se hizo y por qué)<br><br><br>Fase 1: Levantamiento y análisis<br>•	Definición del problema: pedidos manuales y sin control de inventario.<br>•	Identificación de actores: cliente y admin/pastelero.<br>•	Redacción de Historias de Usuario (HU) + criterios de aceptación.<br>Fase 2: Diseño<br>•	Diseño UI/UX (paleta pastel, interfaz minimalista).<br>•	Arquitectura modular (UI/Services/Models).<br>•	Modelado de datos Firestore (colecciones y subcolecciones).<br>•	Diagramas (contexto y contenedores).<br>Fase 3: Implementación<br>•	Autenticación (login/registro).<br>•	Catálogo con Firestore + Streams.<br>•	Carrito persistente por usuario (CarritoItem + FirestoreService).<br>•	CRUD de productos para administración (si aplica).<br>Fase 4: Validación / pruebas<br>•	Pruebas manuales de flujo:<br>o	login/registro<br>o	carga de catálogo<br>o	agregar al carrito<br>o	persistencia por usuario<br>o	reglas de seguridad básicas<br>•	Pruebas de error:<br>o	sin conexión<br>o	credenciales incorrectas<br>o	colecciones vacías<br>Fase 5: Entrega<br>•	README profesional<br>•	Evidencias (capturas, diagramas, tablas)<br>•	Repositorio público o accesible para evaluación<br><br><br>14.	Contribución (Reglas del equipo)<br><br><br>•	Crear una rama por funcionalidad:<br>o	feature/login<br>o	feature/catalogo<br>o	feature/carrito<br>o	feature/admin<br>•	Commits descriptivos:<br>o	“Add FirestoreService for products stream”<br>o	“Implement CarritoItem mapping and add-to-cart”<br>•	Pull Requests:<br>o	revisión por al menos 1 integrante<br>o	mantener main estable<br>=====================================================================</p>

###
